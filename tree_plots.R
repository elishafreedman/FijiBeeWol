##### required packages ####
library(phytools)
library(ape)
library(haplotypes)
library(pegas)
library(treeio)
library(tidytree)


##### upload files #####

# use newick files in order to be able to easily add posteriors to your chart
#use phytools, not the read.nexus or newick functions from ape. Liam did a thing which preserves the data we want to plot!
hosttree <- phytools::read.newick("hosttree.newick")
woltree <- phytools::read.newick("MCca_comb10%_fjWol.newick")

# Sometimes it doesn't preserve the data though :(
#if the phytools read function does not include posteriors, read.beast (for trees generated by BEAST only) will work:
#creates a  s4 class treedata file that has much more information than a class phylo file
hosttree <- treeio::read.beast("MCCA_EF1a2_COI2nd_nameChange.nex")
hosttree1 <- treeio::read.beast("no_colours_hosttree.nex")
hosttree1 <- treeio::read.beast.newick("hosttree.newick")

#subset the info you need. I tried plotting from a treedata file and it did not work.

make_phylo_class <- function(treedata = hosttree){
  tree <- list(edge =  treedata@phylo[["edge"]],
               Nnode = treedata@phylo[["Nnode"]],
               tip.label = treedata@phylo[["tip.label"]],
               edge.length = treedata@phylo[["edge.length"]],
               node.label = treedata@data[["posterior"]])
  class(tree) <- "phylo"
  return(tree)
}

hostree <- make_phylo_class()

# if you already loaded the God damned tree with an empty node.label section can do this as well.
hosttree3$node.label <- hosttree4@data[["posterior"]]

##### prep trees #####

### Look at trees in their raw form first to know what to do  ###
plot(woltree)
nodelables()
###### make trees ####

cophy <- cophylo(woltree, hosttree, assoc = assoc_1)
###### initial plot ####
setEPS()
postscript("output.eps", width = 50, height = 70)
plot(cophy)

#display node lables
nodelabels.cophylo(which = "left")
edgelabels.cophylo(which = "left")

nodelabels.cophylo(which = "right")
edgelabels.cophylo(which = "right")

dev.off()

nodelables.cophylo()

###### drop tips ####

hosttree_tip_drop <- drop.tip(
  hostree,
  c("Homolictus_van_Levu_sp_CM25",
    "Homalictus_spNov_CdS_2",
    "Homalictus_spNov_CdS_1",
    "Homalictus_tuiwawae_c",
    "Homalictus_tuiwawae_b",
    "Homalictus_ostridorsum_b",
    "Phantom_sp",
    "Homalictus_fijiensis_b"
    ),
  trim.internal = TRUE,
  subtree = FALSE,
  root.edge = 0,
  rooted = TRUE,
  collapse.singles = TRUE,
  interactive = FALSE
)


plot(hosttree_tip_drop)

nodelabels(hosttree$trees)

#check node numbers you would like to collapse
setEPS()
postscript("woltree.esp", width = 50, height = 100)
node.num <- plotTree(woltree, node.numbers= TRUE)
dev.off()

#check posteriors to determine
setEPS()
postscript("woltree_edge.esp", width = 100, height = 100)
plot(woltree)
nodelabels(woltree$edge.length)
dev.off()

pdf("woltree.pdf", width = 200, height = 50)
plotTree(woltree, node.numbers = TRUE)
dev.off()

pdf("hosttree.pdf", width = 50, height = 100)
plotTree(hosttree, node.numbers = TRUE)
dev.off()

#' @param tree Tree data data
#' @param clade.label  if NA, clade labels will be automatically assigned
#' @param triangle_depth the proportion of the edge length that will be part of the triangle
#' @param min_edge_length the minimum edge length of branches that should be kept in the backbone
Backbone <-
  function(tree = tree,
           clade.label = NA,
           triangle_depth = 0.5,
           threshold = 0.1,
           min_edge_length = 0.0005
  ){

    #find the nodes to collapse, based on the minimum required posterior probability to determine a real relationship
    P_list <- as.numeric(tree$node.label) >= threshold & tree$edge.length >= min_edge_length
    nodes <- which(P_list == TRUE)
    print(paste(length(nodes), "nodes in backbone, remaining ",
                tree$Nnode-length(nodes), "nodes to be collapsed."))

    #get the number of species, the relevant tip labels, and number of species
    N_sample <- c(rep(NA, length(nodes)))
    tip.label <- c(rep(NA, length(nodes)))
    for(i in 1:length(nodes)){
      decs <- getDescendants(woltree, node = nodes[i])
      #print(decs)
      N_sample[i] <- length(decs)
      tip.label[i] <-  tree$tip.label[decs[2]]
      clade.label[i] <- tree$tip.label[decs[2]] # we can change these later
    }
    #print(tip.label)
    # get the star tips
    depth <-vapply(tip.label,function(x,y)
      triangle_depth*y$edge.length[which(tree$edge[,2]==which(y$tip.label==x))],
      y=tree, numeric())


    trans <- data.frame(tip.label,
                        clade.label,
                        N_sample,
                        depth)
    return(trans)

    newtree <- phylo.toBackbone(tree, trans = trans)
    return(newtree)
  }

wol_tree <- Backbone(tree = woltree,
                     triangle_depth = 0.5,
                     threshold = 1)

###### manually adding a backbone tree #####

nodes <- c(194, 133, 246, 240)

N_sample <- c()
tip.label <- c()
clade.label <- c()
for(i in 1:length(nodes)){
  decs <- getDescendants(woltree, node = nodes[i])
  #print(decs)
  N_sample[i] <- length(decs)
  tip.label[i] <-  woltree$tip.label[decs[2]]
  clade.label[i] <- woltree$tip.label[decs[2]] # we can change these later
}
#print(tip.label)
# get the star tips
depth <-vapply(tip.label,function(x,y)
  triangle_depth*y$edge.length[which(woltree$edge[,2]==which(y$tip.label==x))],
  y=woltree, numeric())


trans <- data.frame(tip.label,
                    clade.label,
                    N_sample,
                    depth)
###### before final plot ####
#' @param tree input tree file
#' @param colours branch colours
#' @param node_labs node labels to start colour change
### colour tree branches by species ###
colour_branches <-
  function(tree = cophy,
           colours = c("#1E88E5",
                       "#FFC107",
                       "#004D40",
                       "#695AEB"),
           node_labs = c(170, 140, 149, 165),
           sides = 1) {
    side <- rep("black", nrow(tree$trees[[sides]]$edge))
    for (i in 1:length(node_labs)) {
      nodes <- getDescendants(tree$trees[[sides]], node_labs[i])
      side[sapply(nodes, function(x, y)
        which(y == x), y = tree$trees[[sides]]$edge[, 2])] <-
        colours[i]
    }
    return(side)
  }
#'@param tree input tree
#'@param assoc_link the column name in the associations data frame you would like to draw the links to colour from
#'@param names The specific names for the associated links to be drawn from
#'@param colours The colours you wish to specify
colour_links <-
  function(tree = cophylo,
           names = c(
             "Homalictus_concavus",
             "Homalictus_kaicolo",
             "Homalictus_atritergus",
             "Homalictus_sp_S",
             "Homalictus_sp_J",
             "Homalictus_sp_F",
             "Homalictus_groomi"
           ),
           colours = c("#D81B60",
                       "#1E88E5",
                       "#FFC107",
                       "#004D40",
                       "#695AEB",
                       "red",
                       "purple"
                       )) {
    link_colours <- rep("black", nrow(tree$assoc))
    col_assign <-
      data.frame(cbind(link_colours, tree$assoc$host))
    for (i in 1:length(names)) {
      col_assign[which(col_assign[,"V2"] == names[i]), 1] <-
        colours[i]
    }
    return(col_assign)
  }

######  Final plot ####
cophy <- cophylo(woltree, hostree, assoc = assoc_1)
#open the esp device and use the functions after the plot to add features to the plot. dev.off() when all features are added to the plot
setEPS()
pdf("cophy.pdf", width = 50, height = 40)
plot(
  cophy,
  link.type = "curved",
  lwd = 4,
  link.col = host_colours$link_colours,
  link.lty = "solid",
  link.lwd = 6,
  fsize = 3,
  use.edge.length = TRUE,
  align.tip.label = FALSE
)

dev.off()


pdf(file = "cophy.pdf", width = 30, height = 40)
plot(
  cophy,
  link.type = "curved",
  edge.col = "black",
  lwd = 4,
  link.col = c(link$link_colours),
  link.lty = "solid",
  link.lwd = 6,
  fsize = 3,
  use.edge.length = TRUE,
  align.tip.label = FALSE
)

dev.off()


####### add posteriors ####
nodelabels.cophylo(
  cophy$trees[[1]]$node.label[2:cophy$trees[[1]]$Nnode],
  edge = sapply(2:cophy$trees[[1]]$Nnode + Ntip(cophy$trees[[1]]),
                function(n, e)
                  which(e == n), e = cophy$trees[[1]]$edge[, 2]),
  frame = "none",
  adj = c(1, 1),
  which = "left"
)
nodelabels.cophylo(
  cophy$trees[[2]]$node.label[2:cophy$trees[[2]]$Nnode],
  edge = sapply(2:cophy$trees[[2]]$Nnode + Ntip(cophy$trees[[2]]),
                function(n, e)
                  which(e == n), e = cophy$trees[[2]]$edge[, 2]),
  frame = "none",
  adj = c(1, 1),
  which = "right"
)
format(X, scientific = FALSE)

#turn off the device
dev.off()

#### Haplotype map ####
### load fasta ###

##### Extract sub tree #####

strain1 <- getDescendants(tree = woltree, node = 132)

strain1_names<- which[woltree$tip.label = strain1]

clade.label[i] <- tree$tip.label[decs[2]]
### get haplotypes ###
h <- haplotype()
d <- dist.dna(h, "N")
nt <- rmst(d, quiet = TRUE)

### haplotype ###
plot.haploNet()

plot(nt)
