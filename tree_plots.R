##### required packages ####
library(phytools)
library(ape)
library(haplotypes)
library(pegas)
library(treeio)
library(tidytree)


##### upload files #####

# use newick files in order to be able to easily add posteriors to your chart
#use phytools, not the read.nexus or newick functions from ape. Liam did a thing which preserves the data we want to plot!
hosttree3 <- phytools::read.newick("hosttree.newick")
woltree <- phytools::read.newick("MCca_comb10%_fjWol.newick")

# Sometimes it doesn't preserve the data though :(
#if the phytools read function does not include posteriors, read.beast (for trees generated by BEAST only) will work:
#creates a  s4 class treedata file that has much more information than a class phylo file
hosttree <- treeio::read.beast("MCCA_EF1a2_COI2nd_nameChangeEdit.nex")

#subset the info you need. I tried plotting from a treedata file and it did not work.

make_phylo_class <- function(treedata = hosttree){
  tree <- list(edge =  treedata@phylo[["edge"]],
       Nnode = treedata@phylo[["Nnode"]],
       tip.label = treedata@phylo[["tip.label"]],
       edge.length = treedata@phylo[["edge.length"]],
       node.label = treedata@data[["posterior"]])

  return(tree)
}

#remember to change the class!!
class(hosttree) <- "phylo"

# if you already loaded the God damned tree with an empty node.lable section can do this as well.
hosttree3$node.label <- hosttree4@data[["posterior"]]

##### prep trees #####

### Look at trees in their raw form first to know what to do  ###
plot(woltree1)
 nodelables()
 ###### make trees ####

 cophy <- cophylo(woltree, hosttree, assoc = assoc_1)
###### initial plot ####
setEPS()
postscript("output.eps", width = 50, height = 70)
plot(cophy)

 #display node lables
nodelabels.cophylo(which = "left")
edgelabels.cophylo(which = "left")

nodelabels.cophylo(which = "right")
edgelabels.cophylo(which = "right")

dev.off()

nodelables.cophylo()

###### drop tips ####
drop.tip(
  phy,
  tip,
  trim.internal = TRUE,
  subtree = FALSE,
  root.edge = 0,
  rooted = is.rooted(phy),
  collapse.singles = TRUE,
  interactive = FALSE
)
# keep.tip(phy, tip)
# extract.clade(phy, node, root.edge = 0, collapse.singles = TRUE,
#               interactive = FALSE)



nodelabels(hosttree$trees)

# Shaded star tips are actually trees that are class "backbonePhylo"

#list the labels for each clade
clade.label <- c("Strain_1", "strain_2","strain_3","strain_4")
tip.label <- c("17FJwol196", "KP208728wsp", "BP172 consensus", "JQ414026_98wsp")
nodes <- c(170, 149, 143, 135)

Backbone <-
  function(tree = tree,
           clade.label = NA,
           nodes = NA,
           tip.label = NA,
           triangle_depth = 0.5
            ){

    #if your tree has many small nodes that need to be collapsed prematurely so the correct number of descendants are selected use this:
    tree <- collapse.to.star(tree, nodes)
    #make tree backbone

    #get the number of species
    N_sample <- c(rep(NA, length(nodes)))
    for(i in 1:length(nodes)){
      N_sample[i] <- length(getDescendants(woltree, node = nodes[i]))
    }

    # get the star tips
    depth <-vapply(tip.label,function(x,y)
      triangle_depth*y$edge.length[which(tree$edge[,2]==which(y$tip.label==x))],
      y=tree, numeric(1))

    trans <- data.frame(tip.label,
                        clade.label,
                        N_sample,
                        depths)

    newtree <- phylo.toBackbone(tree, trans = trans)
    return(newtree)
  }

wol_tree <- Backbone(tree = woltree,
                      clade.label = clade.label,
                      nodes = nodes,
                      tip.label = tip.label)
###### before final plot ####

### colour tree branches by species ###
colour_branches <-
  function(tree = cophy,
           colours = c("#1E88E5",
                       "#FFC107",
                       "#004D40",
                       "#695AEB"),
           node_labs = c(170, 140, 149, 165),
           sides = 1) {
    side <- rep("black", nrow(tree$trees[[sides]]$edge))
    for (i in 1:length(node_labs)) {
      nodes <- getDescendants(tree$trees[[sides]], node_labs[i])
      side[sapply(nodes, function(x, y)
        which(y == x), y = tree$trees[[sides]]$edge[, 2])] <-
        colours[i]
    }
    return(side)
  }


colour_links <-
  function(tree = cophy,
           assoc_link = "Host",
           names = c(
             "Homalictus_concavus",
             "Homalictus_kaicolo",
             "Homalictus_atritergus",
             "Homalictus_sp_S",
             "Homalictus_sp_J"
           ),
           colours = c("#D81B60",
                       "#1E88E5",
                       "#FFC107",
                       "#004D40",
                       "#695AEB")) {
    link_colours <- rep("black", nrow(tree$assoc))
    col_assign <-
      data.frame(cbind(link_colours, tree$assoc[assoc_link]))
    for (i in 1:length(names)) {
      col_assign[which(col_assign[assoc_link] == names[i]), 1] <-
        colours[i]
    }
    return(col_assign)
  }

######  Final plot ####
#open the esp device and use the functions after the plot to add features to the plot. dev.off() when all features are added to the plot
setEPS()
postscript("cophy.eps", width = 30, height = 40)
plot(
  cophy,
  link.type = "curved",
  edge.col = edge.col,
  lwd = 4,
  link.col = c(link$link_colours),
  link.lty = "solid",
  link.lwd = 6,
  fsize = 3,
  use.edge.length = TRUE,
  align.tip.label = FALSE
)

dev.off()


####### add posteriors ####
nodelabels.cophylo(
  cophy$trees[[1]]$node.label[2:cophy$trees[[1]]$Nnode],
  edge = sapply(2:cophy$trees[[1]]$Nnode + Ntip(cophy$trees[[1]]),
                function(n, e)
                  which(e == n), e = cophy$trees[[1]]$edge[, 2]),
  frame = "none",
  adj = c(1, 1),
  which = "left"
)
nodelabels.cophylo(
  cophy$trees[[2]]$node.label[2:cophy$trees[[2]]$Nnode],
  edge = sapply(2:cophy$trees[[2]]$Nnode + Ntip(cophy$trees[[2]]),
                function(n, e)
                  which(e == n), e = cophy$trees[[2]]$edge[, 2]),
  frame = "none",
  adj = c(1, 1),
  which = "right"
)
format(X, scientific = FALSE)

#turn off the device
dev.off()

#### Haplotype map ####

### load fasta ###
### get haplotypes ###
h <- haplotype()
d <- dist.dna(h, "N")
nt <- rmst(d, quiet = TRUE)

### haplotype ###
plot.haploNet()

plot(nt)
