# Check if ComplexHeatmap is installed
# TRUE if ComplexHeatmap is found
suppressWarnings(
CHtest <- system.file(package='ComplexHeatmap') %>%
stringr::str_count() > 0
)
###### b. BiocManager ####
if(CHtest == FALSE){
if(BcMtest == FALSE){
# Set up instructions for download on fail
instructions <- paste(" Please try installing the package for yourself",
"using the following command: \n",
" install.packages(\"BiocManager\")")
# Set up fail function for tryCatch
error_func_BCM <- function(e){
stop(paste("Failed to install the BiocManager package.\n",
instructions))
}
# Begin interactive input
input <- 1
if (interactive()){
input <- utils::menu(c("Yes", "No"),
title = paste0("Install the BiocManager package? \n",
"NOTE: if you need to install BiocManager, you may need to restart R",
" before installing ComplexHeatmap."))
}
if(input == 1){
# Check for BiocManager
if( suppressWarnings(system.file(package='BiocManager')) %>% stringr::str_count() == 0){
message("Installing the BiocManager package.")
tryCatch(
utils::install.packages("BiocManager"),
error = error_func_BCM, warning = error_func_BCM)
}# END BiocManager check
else{
stop(writeLines(paste("The ComplexHeatmap package is necessary for BeeBDC::chordDiagramR.\n",
instructions)))
} # END else
} # END input == 1
}# END BcMtest == FALSE
} # END CHtest == FALSE
###### c. ComplexHeatmap ####
if(CHtest == FALSE){
# Set up instructions for download on fail
instructions <- paste(" Please try installing the package for yourself",
"using the following command: \n",
"BiocManager::install(\"ComplexHeatmap\")")
# Set up fail function for tryCatch
error_func_CH <- function(e){
stop(paste("Failed to install the ComplexHeatmap package.\n",
instructions))
}
# Begin interactive input
input <- 1
if (interactive()){
input <- utils::menu(c("Yes", "No"),
title = paste0("Install the ComplexHeatmap package? \n"))
}
if(input == 1){
# Start ComplexHeatmap install
message("Installing the ComplexHeatmap package.")
tryCatch(
BiocManager::install("ComplexHeatmap"),
error = error_func_CH, warning = error_func_CH)
} # END input == 1
else{
stop(writeLines(paste("The ComplexHeatmap package is necessary for BeeBDC::chordDiagramR.\n",
instructions)))
} # END else
} # END CHtest == FALSE
#### 1.0 Data prep ####
# Create a table to go into chord diagram
suppressMessages(
chordData <- table(dplyr::bind_cols(dupeData$dataSource, dupeData$dataSource_keep)),
classes = "message")
# Create tables of the counts of kept source and duplicate source
keptSource <- table(dupeData$dataSource) %>%
as.data.frame() %>% dplyr::tibble() %>%
stats::setNames(c("sourceName", "Frequency"))
dupeSource <- table(dupeData$dataSource_keep) %>%
as.data.frame() %>% dplyr::tibble() %>%
stats::setNames(c("sourceName", "Frequency_dupe"))
# Merge the sources and get their sum (for a total frequency count to order by)
colourTable <- dplyr::full_join(keptSource, dupeSource, by = "sourceName") %>%
dplyr::mutate(Frequency = (Frequency + Frequency_dupe)) %>%
# Drop the Frequency_dupe column
dplyr::select(!Frequency_dupe) %>%
# Get broad source (before first underscore)
dplyr::mutate( sourceCategories = (sourceName %>%
stringr::str_replace(
string = .,
pattern = "_.*",
replacement = ""
))) %>%
dplyr::group_by(sourceCategories) %>%
dplyr::mutate(  # Count group number
groupCount = dplyr::n(),
# Combine small groups (< smallGrpThreshold)
sourceCategories = dplyr::if_else(
groupCount < smallGrpThreshold, "Other", sourceCategories)) %>%
dplyr::arrange(sourceName, .by_group = TRUE) %>%
# Re-group
dplyr::group_by(sourceCategories) %>%
dplyr::mutate(groupNumber = dplyr::cur_group_id(),
# Re-count
groupCount = dplyr::n(),
groupPalette = palettes[groupNumber]) %>%
# assign colours
dplyr::mutate(groupColours =
paletteer::paletteer_dynamic(
palette = groupPalette[[1]],
n = groupCount[[1]]) %>% list(),
colour = unlist(groupColours)[dplyr::row_number()])
#### 2.0 Build plot ####
circlize::circos.clear()
circlize::circos.par(canvas.ylim = canvas.ylim, canvas.xlim = canvas.xlim)
# Create the chord diagrame
circlize::chordDiagram(
x = chordData,
order = colourTable$sourceName,
directional = 1,
direction.type = c("arrows"),
link.arr.type = "big.arrow",
reduce = 0,
# self links fold directly back onto themselves instead of going to far side
self.link = self.link,
grid.col = colourTable$colour,
keep.diagonal = TRUE,
# name, grid, axis
annotationTrack = c("grid"),
preAllocateTracks = list(
track.height = circlize::mm_h(4),
track.margin = c(circlize::mm_h(1), 0)),
scale = FALSE
)
circlize::circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
xlim = circlize::get.cell.meta.data("xlim")
ylim = circlize::get.cell.meta.data("ylim")
sector.name = circlize::get.cell.meta.data("sector.index")
}, bg.border = NA)
# Highlight inputs
for(i in 1:length(unique(colourTable$sourceCategories))){
loopCat <- colourTable %>%
dplyr::filter(sourceCategories == unique(colourTable$sourceCategories)[i])
circlize::highlight.sector(stringr::str_c(loopCat$sourceName),
track.index = 1, col = loopCat$colour[[1]],
text = unique(loopCat$sourceCategories), cex = 0.8,
text.col = text.col, niceFacing = niceFacing)
}
legendList <- c()
# Make legends by creating a list of legends for each sourceCategory
for(i in 1:length(unique(colourTable$sourceCategories))){
loopCat <- colourTable %>%
dplyr::filter(sourceCategories == unique(colourTable$sourceCategories)[i])
legendList[[i]] <- ComplexHeatmap::Legend(labels = stringr::str_c(loopCat$sourceName),
title = unique(stringr::str_c(loopCat$sourceCategories)),
legend_gp = grid::gpar(fill = c(loopCat$colour)))
} # END legend loop
lgd_list <- ComplexHeatmap::packLegend(list = legendList)
ComplexHeatmap::draw(lgd_list, x = legendX,
y = legendY, just = legendJustify)
circlize::circos.clear()
title(title)
grDevices::dev.copy2pdf(file = paste(outPath, "/", fileName, sep = ""),
height = height, width = width, bg = bg)
#dev.off()
} # END function
chordDiagramR(
# The duplicate data from the dupeSummary function output
dupeData = basicData,
outPath = tempdir(),
fileName = "ChordDiagram.pdf",
# These can be modified to help fit the final pdf that's exported.
width = 9,
height = 7.5,
bg = "white",
# How few distinct dataSources should a group have to be listed as "other"
smallGrpThreshold = 3,
title = "Duplicated record sources",
# The default list of colour palettes to choose from using the paleteer package
palettes = c("cartography::blue.pal", "cartography::green.pal",
"cartography::sand.pal", "cartography::orange.pal", "cartography::red.pal",
"cartography::purple.pal", "cartography::brown.pal"),
canvas.ylim = c(-1.0,1.0),
canvas.xlim = c(-0.6, 0.25),
text.col = "black",
legendX = grid::unit(6, "mm"),
legendY = grid::unit(18, "mm"),
legendJustify = c("left", "bottom"),
niceFacing = TRUE)
remove.packages("BiocManager")
remove.packages("ComplexHeatmap")
chordDiagramR(
# The duplicate data from the dupeSummary function output
dupeData = basicData,
outPath = tempdir(),
fileName = "ChordDiagram.pdf",
# These can be modified to help fit the final pdf that's exported.
width = 9,
height = 7.5,
bg = "white",
# How few distinct dataSources should a group have to be listed as "other"
smallGrpThreshold = 3,
title = "Duplicated record sources",
# The default list of colour palettes to choose from using the paleteer package
palettes = c("cartography::blue.pal", "cartography::green.pal",
"cartography::sand.pal", "cartography::orange.pal", "cartography::red.pal",
"cartography::purple.pal", "cartography::brown.pal"),
canvas.ylim = c(-1.0,1.0),
canvas.xlim = c(-0.6, 0.25),
text.col = "black",
legendX = grid::unit(6, "mm"),
legendY = grid::unit(18, "mm"),
legendJustify = c("left", "bottom"),
niceFacing = TRUE)
library(magrittr)
chordDiagramR(
# The duplicate data from the dupeSummary function output
dupeData = basicData,
outPath = tempdir(),
fileName = "ChordDiagram.pdf",
# These can be modified to help fit the final pdf that's exported.
width = 9,
height = 7.5,
bg = "white",
# How few distinct dataSources should a group have to be listed as "other"
smallGrpThreshold = 3,
title = "Duplicated record sources",
# The default list of colour palettes to choose from using the paleteer package
palettes = c("cartography::blue.pal", "cartography::green.pal",
"cartography::sand.pal", "cartography::orange.pal", "cartography::red.pal",
"cartography::purple.pal", "cartography::brown.pal"),
canvas.ylim = c(-1.0,1.0),
canvas.xlim = c(-0.6, 0.25),
text.col = "black",
legendX = grid::unit(6, "mm"),
legendY = grid::unit(18, "mm"),
legendJustify = c("left", "bottom"),
niceFacing = TRUE)
BiocManager::install("ComplexHeatmap")
BiocManager::install("ComplexHeatmap")
BiocManager::install("ComplexHeatmap")
BiocManager::install("ComplexHeatmap")
BiocManager::install("ComplexHeatmap")
BiocManager::install("ComplexHeatmap")
BiocManager::install("ComplexHeatmap")
BiocManager::install("ComplexHeatmap")
BiocManager::install("ComplexHeatmap")
BiocManager::install("ComplexHeatmap")
BiocManager::install("ComplexHeatmap")
BiocManager::install("ComplexHeatmap")
BiocManager::install("ComplexHeatmap")
chordDiagramR(
# The duplicate data from the dupeSummary function output
dupeData = basicData,
outPath = tempdir(),
fileName = "ChordDiagram.pdf",
# These can be modified to help fit the final pdf that's exported.
width = 9,
height = 7.5,
bg = "white",
# How few distinct dataSources should a group have to be listed as "other"
smallGrpThreshold = 3,
title = "Duplicated record sources",
# The default list of colour palettes to choose from using the paleteer package
palettes = c("cartography::blue.pal", "cartography::green.pal",
"cartography::sand.pal", "cartography::orange.pal", "cartography::red.pal",
"cartography::purple.pal", "cartography::brown.pal"),
canvas.ylim = c(-1.0,1.0),
canvas.xlim = c(-0.6, 0.25),
text.col = "black",
legendX = grid::unit(6, "mm"),
legendY = grid::unit(18, "mm"),
legendJustify = c("left", "bottom"),
niceFacing = TRUE)
?interactive
?countryOutlieRs
?dateFindR
?dupeSummary
?flagSummaryTable
flagTibble <- flagSummaryTable(data = beesFlagged,
column = "scientificName",
outPath = paste0(tempdir()),
fileName = "flagTable.csv")
flagTibble <- BeeBDC::flagSummaryTable(data = beesFlagged,
column = "scientificName",
outPath = paste0(tempdir()),
fileName = "flagTable.csv")
data("beesFlagged")
data("beesFlagged", package = "BeeBDC")
flagTibble <- BeeBDC::flagSummaryTable(data = beesFlagged,
column = "scientificName",
outPath = paste0(tempdir()),
fileName = "flagTable.csv")
summaryTable
summaryTable
##### 9.6 Flag summary ####
# Produce a summary table of flags per species
summaryTable <- BeeBDC::flagSummaryTable(data = beeData,
column = "scientificName",
outPath = OutPath_Report,
fileName = "flagTable.csv",
percentThreshold = 0)
summaryTable
flagTibble <- BeeBDC::flagSummaryTable(data = beesFlagged,
column = "scientificName",
outPath = paste0(tempdir()),
fileName = "flagTable.csv")
flagTibble
View(flagTibble)
View(flagTibble[,c(1:3);27:30])
View(flagTibble[,c(1:3, 27:30)])
View(beesTaxonomy)
View(beesTaxonomy())
View(BeeBDC::beesTaxonomy())
#### 0.0 Prep ####
##### 0.1 Paths ####
# Choose the path to the root folder in which all other folders can be found (or made by dirMaker)
RootPath <- "/Users/jamesdorey/Desktop/Uni/My_papers/Elisha_Hons_paper/Honours/Dorey_script"
# Set the working directory
setwd(RootPath)
# Install reenv, IF NEEDED
#install.packages("renv")
renv::init(project = RootPath)
##### 0.2 Install packages (if needed) #####
# Install only those packages that are not already present in your system
# Choose packages that need to be installed
# You may need to install gdal on your computer. This can be done on mac by using
# Homebrew in the terminal and the command "brew install gdal"
list.of.packages <- c("pegas",
#"apex",
"geodata",
"dplyr",             #  Part of the tidyverse
"adegenet",
"mmod",
"poppr",
"hierfstat",         # For genetics statistics
"readr",
"rnaturalearth",
"rnaturalearthdata",
"maps",
"terra",
"cowplot",
"magrittr",          # to use pipes
#"ggVennDiagram",     # Extends ggplot2 to make venn diagrams
"tibble",            # To use tibbles
"forcats",           # tidyverse for working with factors
"tidyr",             #  Part of the tidyverse)
"tidyselect",        #  Part of the tidyverse
"geodata",
"tidyterra",
"ggspatial",
"devtools")         #  Makes ggplot2 create north arrows or scale bars
##### 0.3 Load packages ####
# Load all packages from the list specified above
lapply(c(list.of.packages),
library, character.only = TRUE)
#### 3.0 Table manipulation ####
CollectionData <- readr::read_csv("HomalictusCollectionData_2018.csv")
CollectionData
wolSeqNames <- readr::read_csv("wolbachiaSpecies.csv")
wolPosNeg <- readr::read_csv("Wolbachia_PositiveNagative.csv")
# Combine
TEST <- CollectionData %>%
dplyr::left_join(wolSeqNames, by = c("Specimen_code" = "homaSp") )
View(TEST)
wolSeqNames <- readr::read_csv("wolbachiaSpecies.csv") %>%
dplyr::distinct()
?left_join
# Combine
TEST <- CollectionData %>%
dplyr::left_join(wolSeqNames, by = c("Specimen_code" = "homaSp") ) %>%
dplyr::left_join(wolSeqNames, by = c("Sequence_name" = "homaSp"),
suffix = c("","_2"))
View(TEST)
# Combine
TEST <- CollectionData %>%
dplyr::left_join(wolSeqNames, by = c("Specimen_code" = "homaSp") ) %>%
dplyr::left_join(wolPosNeg, by = c("Specimen_code" = "seqCode"))
View(TEST)
colnames(TEST)
# Combine
TEST <- CollectionData %>%
dplyr::left_join(wolSeqNames, by = c("Specimen_code" = "homaSp") ) %>%
dplyr::left_join(wolPosNeg, by = c("Specimen_code" = "seqCode")) %>%
dplyr::select(!WolSequencID) %>%
dplyr::distinct()
View(TEST)
# Combine
TEST <- CollectionData %>%
dplyr::left_join(wolSeqNames, by = c("Specimen_code" = "homaSp") ) %>%
dplyr::left_join(wolPosNeg, by = c("Specimen_code" = "seqCode")) %>%
dplyr::select(!WolSequencID) %>%
dplyr::distinct() %>%
readr::write_excel_csv("OccData.csv")
#### 3.0 Table manipulation ####
CollectionData <- readr::read_csv("HomalictusCollectionData_2018.csv")
wolSeqNames <- readr::read_csv("wolbachiaSpecies.csv") %>%
dplyr::distinct()
wolPosNeg <- readr::read_csv("Wolbachia_PositiveNagative.csv")
# Combine
TEST <- CollectionData %>%
dplyr::left_join(wolSeqNames, by = c("Specimen_code" = "homaSp") ) %>%
dplyr::left_join(wolPosNeg, by = c("Specimen_code" = "seqCode")) %>%
dplyr::select(!WolSequencID) %>%
dplyr::distinct() %>%
dplyr::mutate(individualCount = 1) %>%
dplyr::rename(
recordNumber = Specimen_code,
elevationInMeters = Elevation,
decimalLatitude	= Latitude,
decimalLongitude = Longitude,
locality = Location,
recordedBy = Collectors,
eventDate = Date,
eventTime = time,
yeay = Year,
sex = Sex,
fieldNotes = Notes,
scientificName = Species_name) %>%
readr::write_excel_csv("OccData.csv")
# Combine
TEST <- CollectionData %>%
dplyr::left_join(wolSeqNames, by = c("Specimen_code" = "homaSp") ) %>%
dplyr::left_join(wolPosNeg, by = c("Specimen_code" = "seqCode")) %>%
dplyr::select(!WolSequencID) %>%
dplyr::distinct() %>%
dplyr::mutate(individualCount = 1) %>%
dplyr::rename(
recordNumber = Specimen_code,
elevationInMeters = Elevation,
decimalLatitude	= Latitude,
decimalLongitude = Longitude,
locality = Location,
recordedBy = Collectors,
eventDate = Date,
eventTime = Time,
yeay = Year,
sex = Sex,
fieldNotes = Notes,
scientificName = Species_name) %>%
readr::write_excel_csv("OccData.csv")
# Combine
TEST <- CollectionData %>%
dplyr::left_join(wolSeqNames, by = c("Specimen_code" = "homaSp") ) %>%
dplyr::left_join(wolPosNeg, by = c("Specimen_code" = "seqCode")) %>%
dplyr::select(!WolSequencID) %>%
dplyr::distinct() %>%
dplyr::mutate(individualCount = 1) %>%
dplyr::rename(
recordNumber = Specimen_code,
elevationInMeters = Elevation,
decimalLatitude	= Latitude,
decimalLongitude = Longitude,
locality = Location,
recordedBy = Collectors,
eventDate = Date,
eventTime = Time,
yeay = Year,
sex = Sex,
fieldNotes = Notes,
scientificName = Species_name) %>%
dplyr::mutate(eventDate = eventDAte %>%
lubridate::dmy()) %>%
readr::write_excel_csv("OccData.csv")
# Combine
TEST <- CollectionData %>%
dplyr::left_join(wolSeqNames, by = c("Specimen_code" = "homaSp") ) %>%
dplyr::left_join(wolPosNeg, by = c("Specimen_code" = "seqCode")) %>%
dplyr::select(!WolSequencID) %>%
dplyr::distinct() %>%
dplyr::mutate(individualCount = 1) %>%
dplyr::rename(
recordNumber = Specimen_code,
elevationInMeters = Elevation,
decimalLatitude	= Latitude,
decimalLongitude = Longitude,
locality = Location,
recordedBy = Collectors,
eventDate = Date,
eventTime = Time,
yeay = Year,
sex = Sex,
fieldNotes = Notes,
scientificName = Species_name) %>%
dplyr::mutate(eventDate = eventDate %>%
lubridate::dmy()) %>%
readr::write_excel_csv("OccData.csv")
View(TEST)
# Combine
TEST <- CollectionData %>%
dplyr::left_join(wolSeqNames, by = c("Specimen_code" = "homaSp") ) %>%
dplyr::left_join(wolPosNeg, by = c("Specimen_code" = "seqCode")) %>%
dplyr::select(!WolSequencID) %>%
dplyr::distinct() %>%
dplyr::mutate(individualCount = 1) %>%
dplyr::rename(
recordNumber = Specimen_code,
elevationInMeters = Elevation,
decimalLatitude	= Latitude,
decimalLongitude = Longitude,
locality = Location,
recordedBy = Collectors,
eventDate = Date,
eventTime = Time,
yeay = Year,
sex = Sex,
fieldNotes = Notes,
scientificName = Species_name) %>%
dplyr::mutate(eventDate = eventDate %>%
lubridate::dmy()) %>%
readr::write_excel_csv("OccData.csv")
